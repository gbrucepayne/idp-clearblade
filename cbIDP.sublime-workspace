{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Return",
				"ReturnMessages"
			],
			[
				"For",
				"ForwardMessages"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "function GetReturnMessages(req, resp){\n    \n    var _access_id = req.params.access_id;\n    var _password = req.params.password;\n    var _from_id = req.params.from_id;\n    var _start_utc = req.params.start_utc;\n    var _end_utc = req.params.end_utc;\n    \n    var callTime = new Date();\n    log(\"Service GetReturnMessages called at: \" + callTime);\n    \n    var successMsg = \"\";\n    var retrievedCount = 0;\n    var storedCount = 0;\n    var byteCount = 0;\n    //var reRetrievedCount = 0;   // reRetrievedCount = retrievedCount - storedCount\n    \n    var api_options = {\n        \"include_raw_payload\": true,\n        \"include_type\": true,\n    };\n\n    \n    var getReturnMessagesCallback = function(err, data){\n        \n        log(\"getReturnMessagesCallback called with \" + JSON.stringify(data));\n        var updateIdpRawMessages = function(message){\n            log(\"Updating IdpRawMessages collection\")\n            var collection = ClearBlade.Collection({collectionName:\"IdpRawMessages\"});\n            // log(\"Data passed to update: \" + JSON.stringify(message));\n            var base64Payload = base64ArrayBuffer(message.RawPayload);\n            // log(\"Base 64 payload: \" + base64Payload);\n            var newRow = {\n                \"timestamp\": timestamp_rfc3339(message.ReceiveUTC),\n                \"msg_id\": message.ID,\n                \"mobile_id\": message.MobileID,\n                \"mo_msg\": true,\n                \"msg_sin\": message.SIN,\n                \"msg_min\": (typeof message.Payload !== \"undefined\") ? message.Payload.MIN:message.RawPayload[0],  // handle null case?\n                \"msg_rawpayload_b64\": base64Payload,\n                \"msg_size_ota\": message.OTAMessageSize,\n                \"access_id\": _access_id\n            };\n\n            var createItemCallback = function(err, collectionData) {\n                if(err){\n                    resp.error(collectionData);\n                } else {\n                    storedCount += 1;\n                    byteCount += newRow.OTAMessageSize;\n                    log(\"Stored message ID \" + newRow.msg_id);\n                }\n            };\n\n            var qNewMsgCallback = function(err, qResult){\n                if (err){\n                    resp.error(qResult);\n                } else {\n                    if (qResult.DATA.length === 0){    // no matching entry in RawMessages collection\n                        collection.create(newRow, createItemCallback);\n                    } else {\n                        log(\"Duplicate message found in IdpRawMessages.  Update skipped for msg_id \" + newRow.msg_id);\n                    }\n                }\n            };\n            \n            var qNewMsg = ClearBlade.Query({collectionName:\"IdpRawMessages\"});\n            qNewMsg.equalTo(\"msg_id\", newRow.msg_id);\n            qNewMsg.equalTo(\"mobile_id\", newRow.mobile_id);\n            qNewMsg.equalTo(\"timestamp\", newRow.timestamp);\n            qNewMsg.fetch(qNewMsgCallback);\n        };\n        \n        var updateIdpRestApiCalls = function(data) {\n            log(\"Updating IdpRestApiCalls\")\n            var collection = ClearBlade.Collection({collectionName:\"IdpRestApiCalls\"});\n            var newRow = {\n                \"call_time\": callTime,\n                \"api_operation\": \"get_return_messages\",\n                \"success\": (data.ErrorID === 0),\n                \"error_id\": data.ErrorID,\n                \"more_messages\": data.More,\n                \"messages_count\": retrievedCount,\n                \"bytes_ota\": byteCount,\n                \"next_start_utc\": data.NextStartUTC,\n                \"next_start_id\": data.NextStartID,\n                \"access_id\": _access_id\n            };\n            var newRowCallback = function(err, collectionData) {\n                if(err){\n                    resp.error(collectionData);\n                } else {\n                    log(\"IdpRestApiCalls collection item added: \" + JSON.stringify(collectionData));\n                }\n            };\n            log(\"Next Start ID: \" + newRow.next_start_id + \" | Next Start UTC: \" + newRow.next_start_utc);\n            collection.create(newRow, newRowCallback);\n        };\n        \n        if(err) {\n            resp.error(\"getReturnMessagesCallbackerror: \" + JOSN.stringify(data));\n        } else {\n            if (data.ErrorID > 0) {\n                resp.error(\"IDP API error: \" + getErrorMessage(data.ErrorID));\n            } else if (data.Messages !== null) {\n                for (var i=0; i < data.Messages.length; i++) {\n                    retrievedCount += 1;\n                    //byteCount += data.Messages[i].OTAMessageSize; //TODO: determine byte count only from new unique messages\n                    log(\"Parsing: \" + JSON.stringify(data.Messages[i]));\n                    updateIdpRawMessages(data.Messages[i]);\n                    //TODO: add parsing checks for supported messages\n                    if (data.Messages[i].Payload !== \"undefined\") {\n                        log(\"Parsing possible on message \" + data.Messages[i].ID);\n                    }\n                }\n                // TODO: push messages, perhaps in MQTT / OneM2M\n                successMsg = \"Return Messages Retrieved: \" + retrievedCount + \" | Stored: \" + storedCount;\n            } else {\n                successMsg = \"No messages to retrieve.\";\n            }\n            // log(\"Storing call time: \" + callTime);\n            updateIdpRestApiCalls(data);\n            if (data.More) {\n                log(\"More messages pending retrieval.\");\n                // TODO: trigger next GetReturnMessages call\n            }\n        }\n    };  // getReturnMessagesCallback\n    \n    ClearBlade.init({request:req});\n    \n    var getWatermarks = function(access_id) {\n        \n        log(\"getWatermarks called\")\n        if (typeof _from_id !== \"undefined\" && _from_id !== \"\") {\n            log(\"Using parameter _from_id = \" + _from_id);\n            api_options.from_id = _from_id;\n        } else if(typeof _start_utc === \"undefined\" || _start_utc === \"\") {\n            log(\"Attempting to fetch next_start_id since _from_id and _start_utc are not defined.\");\n            var qNextIdCallback = function(err, qResult) {\n                // log(\"qNextId response: \" + JSON.stringify(qResult));\n                if (err) {\n                    resp.error(err);\n                } else if(qResult.DATA.length > 0) {\n                    _from_id = qResult.DATA[0].next_start_id;\n                    log(\"Found next_start_id = \" + _from_id);\n                } else {\n                    log(\"No valid next_start_id found. Leaving from_id undefined.\");\n                }\n                if (_from_id !== \"\") {\n                    api_options.from_id = _from_id;\n                }\n            };\n            var qNextId = ClearBlade.Query({collectionName:\"IdpRestApiCalls\"});\n            qNextId.equalTo(\"api_operation\", \"get_return_messages\");\n            qNextId.equalTo(\"access_id\", _access_id);\n            qNextId.notEqualTo(\"next_start_id\", -1);\n            qNextId.descending(\"item_id\");\n            qNextId.fetch(qNextIdCallback);\n        }\n        \n        if (typeof _start_utc !== \"undefined\" && _start_utc !== \"\") {     // TODO: improve with check for valid timestamp\n            log(\"Using parameter _start_utc = \" + _start_utc);\n        } else if(typeof _from_id === \"undefined\" || _from_id === \"\") {\n            log(\"Attempting to fetch next_start_utc since _from_id and _start_utc are not defined.\");\n            var qNextUtcCallback = function(err, qResult) {\n                // log(\"qNextUtc response: \" + JSON.stringify(qResult));\n                if (err) {\n                    resp.error(err);\n                } else if(qResult.DATA.length > 0) {\n                    _start_utc = qResult.DATA[0].next_start_utc;\n                    log(\"Found next_start_utc = \" + _start_utc);\n                } else {\n                    _start_utc = getIdpDefaultTimestamp();\n                    log(\"No valid next_start_utc found. Using \" + _start_utc);\n                }\n                if (_start_utc !== \"\") {\n                    api_options.start_utc = _start_utc;\n                }\n            };\n            var qNextUtc = ClearBlade.Query({collectionName:\"IdpRestApiCalls\"});\n            qNextUtc.equalTo(\"api_operation\", \"get_return_messages\");\n            qNextUtc.equalTo(\"access_id\", _access_id);\n            qNextUtc.notEqualTo(\"next_start_utc\", \"\");\n            qNextUtc.descending(\"item_id\");\n            qNextUtc.fetch(qNextUtcCallback);\n        }\n        \n        if (_start_utc !== \"\" && typeof _end_utc !== \"undefined\" && _end_utc !== \"\") {  // TODO: check that end_utc > start_utc\n            log(\"Using parameter _end_utc\");\n            api_options.end_utc = _end_utc;\n        }\n        \n    };\n\n    // If no accessID provided, loop through available Mailboxes\n    log(\"Start: getting API access details\")\n    if (typeof _access_id !== \"undefined\" && _access_id !== \"\") {\n        log(\"Using parameter _access_id.\");\n    } else {\n        log(\"Mailbox accessID not provided. Looping through available Mailboxes.\");\n        var qMailboxesCallback = function(err, qResult) {\n            if (err) {\n                resp.error(err);\n            } else if (qResult.DATA.length > 0) {\n                for (var i=0; i < qResult.DATA.length; i++) {\n                    _access_id = qResult.DATA[i].access_id;\n                    _password = qResult.DATA[i].password;\n                    log(\"Using accessID = \" + _access_id);\n                    if (i === 0) {\n                        log(\"Using watermark parameters for first mailbox \" + _access_id);\n                    } else {\n                        log(\"Resetting watermarks for next mailbox \" + _access_id);\n                        _from_id = \"\";\n                        _start_utc = \"\";\n                        _end_utc = \"\";\n                    }\n                    //getWatermarks(_access_id);\n                }\n            } else {\n                log(\"Unable to determine valid Mailbox.\");\n                resp.error(\"Mailboxes collection is empty, cannot get_return_messages.\");\n            }\n        };\n        var qMailboxes = ClearBlade.Query({collectionName:\"Mailboxes\"});\n        qMailboxes.fetch(qMailboxesCallback);\n    }\n    \n    getWatermarks(_access_id);\n    getReturnMessages(_access_id, _password, getReturnMessagesCallback, api_options);\n    \n    if (successMsg !== \"\") {\n        if (storedCount > 0) {\n            log(\"Sending notification of new MO message(s) received.\");\n            notifyIdpReturn(storedCount);\n        }\n        resp.success(successMsg);\n    }\n}",
			"settings":
			{
				"buffer_size": 10568,
				"line_ending": "Windows"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 137.0,
		"last_filter": "install",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"",
				"Install Package Control"
			]
		],
		"width": 412.0
	},
	"console":
	{
		"height": 130.0,
		"history":
		[
			"os.system('git --version')",
			"os.getenv()",
			"os",
			"print os.getenv('PATH')",
			"import os",
			"import os; print os.getenv('PATH')"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"file_history":
	[
		"/H/Product/IDP/Developer Kit/idpmodemsample.idpmsg",
		"/H/Tutorial-JavaScript/js/part6.js",
		"//gemini/P13795$/Tutorial-JavaScript/js/part1.js",
		"/H/Tutorial-JavaScript/index.html",
		"/H/Product/CAP/GSatTrack/DEMO 2017-06-28 FW524/FleetINT_demo_20170628.idpmsg",
		"/H/Product/Multitech/Conduit AEP/hello-world-python/manifest.json",
		"/H/Product/Multitech/Conduit AEP/hello-world-python/Start",
		"/H/Product/Multitech/Conduit AEP/hello-world-python/Install"
	],
	"find":
	{
		"height": 40.0
	},
	"find_in_files":
	{
		"height": 0.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10568,
						"regions":
						{
						},
						"selection":
						[
							[
								541,
								541
							]
						],
						"settings":
						{
							"syntax": "Packages/JavaScript/JavaScript.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "cbIDP.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 150.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
